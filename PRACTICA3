set serveroutput on;


--recapitulando lo que es un bloque pl sql

DECLARE 
nombre varchar2(20):= 'valeria';
BEGIN
DBMS_OUTPUT.PUT_LINE('BUENAS NOCHES'|| NOMBRE);
END;
/



DECLARE
EDAD INTEGER:=25;
DIAS INTEGER;

ESTATUS VARCHAR(12);
BEGIN
DIAS:=EDAD*365;
IF DIAS>10000 THEN
ESTATUS:='VIEJO';
ELSE 
ESTATUS:='JOVEN';
END IF;

DBMS_OUTPUT.PUT_LINE('TU EDAD EN DIAS ES '||DIAS||'ESTATUS:'||ESTATUS);
END;
/

--VEREMOS NUESTRO PRIMER PROCEDIMIENTO ALMACENADO

CREATE OR REPLACE PROCEDURE SALUDAR(MENSAJE IN VARCHAR2)--ES COMO CREATE TABLE OR REPLACE PERMITE MODIFICARLO DESPUES QUE LA LOGICA NO FUNCIONO,GENERAR UN PROCEDIMIENTO,SOLO
--LLEVA PARENTESIS CUANDO VA A LLEVAR UNA VARIABLE DE ENTRADA
AS --DECLARE ES EQUIVALENTE
BEGIN
DBMS_OUTPUT.PUT_LINE('HOLA BUENAS NOCHES' || MENSAJE);
END;

/

--EJECUTAMOS EN PROCEDIMIENTO 

EXEC SALUDAR ('VALERIA SERNA');

--GENERAMOS LA SECUENCIA
CREATE SEQUENCE SEC_PERSONA--APLICA A LA TABLA QUE SE VA A NOMBRAR
START WITH 1 --NORMALMENTE SE INCREMENTA DE UNO EN UNO
INCREMENT BY 1
NOMAXVALUE;

--GENERAMOS LA TABLA
CREATE TABLE PERSONA(ID_PERSONA INTEGER,NOMBRE VARCHAR2(20),EDAD INTEGER,CONSTRAINT PK_ID_PERSONA PRIMARY KEY(ID_PERSONA));

--CONTRAINT RESTRICCION SIEMPRE VA A IR PARA CADA CLAVE FORANEA O PRIMARIA

--                                                PK ARTIFICIAL SE AUTOGENERA
CREATE OR REPLACE PROCEDURE GUARDAR_PERSONA(MY_ID OUT INTEGER,MY_NOMBRE IN VARCHAR2,MY_EDAD IN INTEGER)--
AS
BEGIN 
SELECT SEC_PERSONA.NEXTVAL INTO MY_ID FROM DUAL;--ES UN CURSOR ES UN JOIN VA A UNIR DOS ESTRUCTURAS LA SECUENCIA DE ,EL PROXIMO VALOR DE LA SECUENCIA NEXT VAL LO INCREMENTA EN 
--UNO DENTRO DE LA VARIABLE DE LA SALIDA ID 
INSERT INTO PERSONA VALUES(MY_ID,MY_NOMBRE,MY_EDAD);-- 
END;
/

DECLARE
---ASI SON LOS INSERT EN ORACLE 
VALOR INTEGER;
BEGIN
GUARDAR_PERSONA(VALOR,'VALERIA',25);
END;
/
SELECT *FROM PERSONA;
